'''
테트로미노 골드4

접근법 :
입력은 N,M 으로 들어오고 최대 400이다
NxM 을 모두 일일히 탐색해야 하기 때문에 최대 250000번의 탐색
시간복잡도는 브루트포스로 풀어도 괜찮을 것 같다

00
00 
--------
0000   0
       0
       0
       0
--------
0    0  00  00                     
0    0  0    0                     
00  00  0    0           그 외 4가지 더            
--------
와 같이 여러 모양의 경우의 수를 고려해야한다
합계를 구하는 방법은 당장 떠오르는건 합계용 함수를 여럿 만들어
일일히 다르게 검사하는 것이다 좀 더 간편화 할 수 있는 방법이 없을까?

'''


def check(x, y):
    result = 0
    for condition in tetris:
        flag = True
        for a, b in condition:
            if a+x >= m or a+x < 0 or b+y >= n or b+y < 0:
                flag = False
                break
        if flag == False:
            continue
        s = 0
        for a, b in condition:
            s += l[y+b][x+a]
        result = max(result, s)
    return result


n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
# 테트로미노의 모든 경우의 수를 0,0 기준의 좌표값을 저장해둔다.
tetris = [[(0, 0), (0, 1), (0, 2), (0, 3)],
          [(0, 0), (1, 0), (2, 0), (3, 0)],
          [(0, 0), (1, 0), (0, 1), (1, 1)],
          [(0, 0), (1, 0), (2, 0), (2, 1)],
          [(0, 1), (1, 1), (2, 1), (2, 0)],
          [(0, 0), (0, 1), (1, 1), (2, 1)],
          [(0, 0), (0, 1), (1, 0), (2, 0)],
          [(0, 0), (1, 0), (1, 1), (1, 2)],
          [(0, 2), (1, 1), (1, 2), (1, 0)],
          [(0, 0), (0, 1), (0, 2), (1, 2)],
          [(0, 0), (1, 0), (0, 1), (0, 2)],
          [(0, 0), (1, 0), (1, 1), (2, 1)],
          [(0, 1), (1, 1), (1, 0), (2, 0)],
          [(1, 0), (1, 1), (0, 1), (0, 2)],
          [(0, 0), (0, 1), (1, 1), (1, 2)],
          [(0, 1), (1, 0), (1, 1), (1, 2)],
          [(0, 0), (0, 1), (0, 2), (1, 1)],
          [(0, 0), (1, 0), (1, 1), (2, 0)],
          [(0, 1), (1, 1), (1, 0), (2, 1)]]
result = 0
for i in range(m):
    for j in range(n):
        result = max(result, check(i, j))
print(result)
