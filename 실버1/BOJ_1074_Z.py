import sys


def recursion(s1, s2, e1, e2, n):
    if n == 0:
        return 0
    result = 0
    m1 = (s1+e1)/2
    m2 = (s2+e2)/2

    if r < m1 and c < m2:
        return result + recursion(s1, s2, m1, m2, n-1)
    else:
        result += (2**(n-1))*(2**(n-1))

    if r < m1 and c >= m2:
        return result + recursion(s1, m2, m1, e2, n-1)
    else:
        result += (2**(n-1))*(2**(n-1))

    if r >= m1 and c < m2:
        return result + recursion(m1, s2, e1, m2, n-1)
    else:
        result += (2**(n-1))*(2**(n-1))

    if r >= m1 and c >= m2:
        return result + recursion(m1, m2, e1, e2, n-1)
    else:
        result += (2**(n-1))*(2**(n-1))


n, r, c = map(int, input().split())
sys.setrecursionlimit(10 ** 5)


print(recursion(0, 0, 2**n, 2**n, n))
'''
Z 실버1
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
0.5 초 (추가 시간 없음)	512 MB	56369	21476	16189	39.398%
문제
한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.



N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.

다음 예는 22 × 22 크기의 배열을 방문한 순서이다.



N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.

다음은 N=3일 때의 예이다.



입력
첫째 줄에 정수 N, r, c가 주어진다.

출력
r행 c열을 몇 번째로 방문했는지 출력한다.

제한
1 ≤ N ≤ 15
0 ≤ r, c < 2N
예제 입력 1 
2 3 1
예제 출력 1 
11
예제 입력 2 
3 7 7
예제 출력 2 
63
예제 입력 3 
1 0 0
예제 출력 3 
0
예제 입력 4 
4 7 7
예제 출력 4 
63
예제 입력 5 
10 511 511
예제 출력 5 
262143
예제 입력 6 
10 512 512
예제 출력 6 
786432

접근법 :
분할 정복으로 풀면 된다.
해보겠다
사등분 해서 왼쪽 위 오른쪽 위 왼쪽 아래 오른쪽 아래 순으로 체크하며
결과값을 누적시킨다.

여러 시도를 해보았다 
재귀를 안 쓰고 풀어보려고 했는데 가능은 해보이는데 재귀가 더 쉬워 보여서 중간에 갈아엎었다
조건문 논리 짤 때 분명 쉬운 조건문인데 잠을 덜 자서인지 집중이 잘 안되고 헷갈려서 삽질을 많이 했다
알고리즘 문제는 정신 말짱할 때 풀어야겠다...
분할 정복이 어떤 느낌인지 알 수 있어서 좋았다

'''
